<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ¯æ—¥æ—¶é—´ç»Ÿè®¡ - Daily Time Stats</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
      padding: 20px;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      min-height: 100vh;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
      background: white;
      border-radius: 24px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .header {
      padding: 24px 32px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .header h1 {
      font-size: 24px;
      font-weight: 600;
    }

    .date-selector {
      display: flex;
      align-items: center;
      gap: 12px;
      background: rgba(255, 255, 255, 0.2);
      padding: 8px 16px;
      border-radius: 12px;
      backdrop-filter: blur(10px);
    }

    .date-selector input {
      background: transparent;
      border: none;
      color: white;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
    }

    .date-selector input::-webkit-calendar-picker-indicator {
      filter: invert(1);
      cursor: pointer;
    }

    .content {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1px;
      background: #e5e7eb;
    }

    .panel {
      background: white;
      padding: 32px;
    }

    .panel-title {
      font-size: 14px;
      font-weight: 600;
      color: #6b7280;
      margin-bottom: 20px;
      text-align: center;
    }

    /* å·¦ä¾§æ—¶é—´è½´æ ·å¼ */
    .timeline-container {
      display: flex;
      gap: 24px;
      align-items: center;
    }

    .timeline-section {
      flex: 1;
    }

    .timeline-header {
      font-size: 18px;
      font-weight: 600;
      color: #374151;
      margin-bottom: 16px;
      text-align: center;
    }

    .timeline-hours {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .hour-row {
      display: flex;
      align-items: center;
      gap: 8px;
      height: 24px;
    }

    .hour-label {
      font-size: 12px;
      color: #6b7280;
      font-weight: 500;
      min-width: 40px;
      text-align: right;
    }

    .hour-bar-container {
      flex: 1;
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .hour-bar {
      height: 20px;
      border-radius: 10px;
      transition: all 0.3s ease;
      position: relative;
      min-width: 8px;
    }

    .hour-bar:hover {
      transform: scaleY(1.2);
      filter: brightness(1.1);
      z-index: 10;
    }

    .hour-bar.empty {
      background: #f3f4f6;
      opacity: 0.5;
    }

    /* å³ä¾§é¥¼å›¾æ ·å¼ */
    .chart-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 24px;
    }

    .date-display {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 24px;
      font-weight: 600;
      color: #1f2937;
    }

    .date-nav {
      background: #f3f4f6;
      border: none;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
    }

    .date-nav:hover {
      background: #e5e7eb;
      transform: scale(1.1);
    }

    .pie-chart {
      position: relative;
      width: 200px;
      height: 200px;
    }

    .pie-chart svg {
      transform: rotate(-90deg);
    }

    .pie-percentage {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 36px;
      font-weight: 700;
      color: #1f2937;
    }

    .legend {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      border-radius: 8px;
      transition: all 0.2s;
    }

    .legend-item:hover {
      background: #f9fafb;
      transform: translateX(4px);
    }

    .legend-left {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .legend-name {
      font-size: 14px;
      color: #374151;
      font-weight: 500;
    }

    .legend-duration {
      font-size: 14px;
      color: #6b7280;
      font-weight: 600;
    }

    .empty-state {
      text-align: center;
      color: #9ca3af;
      padding: 40px;
      font-size: 14px;
    }

    .stats-summary {
      display: flex;
      justify-content: space-around;
      padding: 16px;
      background: #f9fafb;
      border-radius: 12px;
      margin-top: 12px;
    }

    .stat-item {
      text-align: center;
    }

    .stat-value {
      font-size: 18px;
      font-weight: 700;
      color: #1f2937;
    }

    .stat-label {
      font-size: 12px;
      color: #6b7280;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>ğŸ“Š æ¯æ—¥æ—¶é—´ç»Ÿè®¡</h1>
      <div class="date-selector">
        <label for="dateInput">é€‰æ‹©æ—¥æœŸï¼š</label>
        <input type="date" id="dateInput" />
      </div>
    </div>

    <div class="content">
      <!-- å·¦ä¾§ï¼šæ—¶é—´è½´è§†å›¾ -->
      <div class="panel">
        <div class="timeline-container">
          <div class="timeline-section">
            <div class="timeline-header">ä¸Šåˆ</div>
            <div class="timeline-hours" id="amTimeline"></div>
          </div>
          <div class="timeline-section">
            <div class="timeline-header">ä¸‹åˆ</div>
            <div class="timeline-hours" id="pmTimeline"></div>
          </div>
        </div>
        
        <div class="stats-summary" id="totalStats">
          <div class="stat-item">
            <div class="stat-value" id="totalBusy">0h</div>
            <div class="stat-label">å·²å®‰æ’</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="totalFree">0h</div>
            <div class="stat-label">ç©ºç™½</div>
          </div>
        </div>
      </div>

      <!-- å³ä¾§ï¼šé¥¼å›¾ + åˆ†ç±»ç»Ÿè®¡ -->
      <div class="panel">
        <div class="chart-container">
          <div class="date-display">
            <button class="date-nav" id="prevDay">â—€</button>
            <span id="dateText">6æœˆ17æ—¥</span>
            <button class="date-nav" id="nextDay">â–¶</button>
          </div>

          <div class="pie-chart">
            <svg width="200" height="200" id="pieChart"></svg>
            <div class="pie-percentage" id="piePercentage">0%</div>
          </div>

          <div class="legend" id="legend"></div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import { EventService } from '../src/services/EventService.js';
    import { TagService } from '../src/services/TagService.js';

    let currentDate = new Date();
    let allEvents = [];
    let calendarCache = new Map();

    // åˆå§‹åŒ–
    async function init() {
      // è®¾ç½®é»˜è®¤æ—¥æœŸä¸ºä»Šå¤©
      const dateInput = document.getElementById('dateInput');
      dateInput.value = formatDateInput(currentDate);
      updateDateDisplay();

      // åŠ è½½æ—¥å†ç¼“å­˜
      const cacheStr = localStorage.getItem('calendarCache');
      if (cacheStr) {
        try {
          const cacheData = JSON.parse(cacheStr);
          calendarCache = new Map(cacheData.map(c => [c.id, c]));
        } catch (e) {
          console.warn('Failed to load calendar cache:', e);
        }
      }

      // åŠ è½½æ•°æ®
      await loadDayStats();

      // äº‹ä»¶ç›‘å¬
      dateInput.addEventListener('change', (e) => {
        currentDate = new Date(e.target.value);
        updateDateDisplay();
        loadDayStats();
      });

      document.getElementById('prevDay').addEventListener('click', () => {
        currentDate.setDate(currentDate.getDate() - 1);
        dateInput.value = formatDateInput(currentDate);
        updateDateDisplay();
        loadDayStats();
      });

      document.getElementById('nextDay').addEventListener('click', () => {
        currentDate.setDate(currentDate.getDate() + 1);
        dateInput.value = formatDateInput(currentDate);
        updateDateDisplay();
        loadDayStats();
      });
    }

    function formatDateInput(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    function updateDateDisplay() {
      const month = currentDate.getMonth() + 1;
      const day = currentDate.getDate();
      document.getElementById('dateText').textContent = `${month}æœˆ${day}æ—¥`;
    }

    async function loadDayStats() {
      try {
        // è·å–å½“å¤©çš„äº‹ä»¶
        allEvents = await EventService.getAllEvents();
        
        const dateStr = formatDateInput(currentDate);
        const dayEvents = allEvents.filter(event => {
          if (!event.startTime) return false;
          const eventDate = event.startTime.substring(0, 10);
          return eventDate === dateStr;
        });

        console.log(`Found ${dayEvents.length} events for ${dateStr}`);
        
        // ç»Ÿè®¡æ¯å°æ—¶çš„æ•°æ®
        const hourlyData = calculateHourlyData(dayEvents);
        
        // ç»Ÿè®¡åˆ†ç±»æ•°æ®
        const categoryStats = calculateCategoryStats(dayEvents);
        
        // æ¸²æŸ“è§†å›¾
        renderTimeline(hourlyData);
        renderPieChart(categoryStats);
        renderLegend(categoryStats);
        updateSummary(hourlyData, categoryStats);

      } catch (error) {
        console.error('Failed to load day stats:', error);
      }
    }

    function calculateHourlyData(events) {
      const hourlyData = {};
      
      // åˆå§‹åŒ– 0-23 å°æ—¶
      for (let h = 0; h < 24; h++) {
        hourlyData[h] = [];
      }

      events.forEach(event => {
        if (!event.startTime || !event.endTime) return;

        const start = new Date(event.startTime);
        const end = new Date(event.endTime);
        
        // è·å–äº‹ä»¶çš„é¢œè‰²
        const color = getEventColor(event);
        const name = getEventName(event);

        // è®¡ç®—è·¨è¶Šçš„å°æ—¶
        let currentHour = start.getHours();
        const endHour = end.getHours();
        const endMinute = end.getMinutes();

        while (currentHour <= endHour) {
          const hourStart = currentHour === start.getHours() ? start.getMinutes() : 0;
          const hourEnd = currentHour === endHour ? endMinute : 60;
          const duration = hourEnd - hourStart;

          if (duration > 0) {
            hourlyData[currentHour].push({
              duration,
              color,
              name,
              event
            });
          }

          currentHour++;
        }
      });

      return hourlyData;
    }

    function calculateCategoryStats(events) {
      const stats = new Map();
      let totalMinutes = 0;

      events.forEach(event => {
        if (!event.startTime || !event.endTime) return;

        const start = new Date(event.startTime);
        const end = new Date(event.endTime);
        const minutes = (end - start) / 1000 / 60;
        
        totalMinutes += minutes;

        const name = getEventName(event);
        const color = getEventColor(event);

        if (!stats.has(name)) {
          stats.set(name, {
            name,
            color,
            minutes: 0,
            count: 0
          });
        }

        const stat = stats.get(name);
        stat.minutes += minutes;
        stat.count++;
      });

      // è½¬æ¢ä¸ºæ•°ç»„å¹¶æ’åº
      const result = Array.from(stats.values())
        .sort((a, b) => b.minutes - a.minutes);

      result.forEach(stat => {
        stat.percentage = totalMinutes > 0 ? (stat.minutes / totalMinutes * 100) : 0;
      });

      return result;
    }

    function getEventColor(event) {
      // ä¼˜å…ˆä½¿ç”¨æ—¥å†é¢œè‰²
      if (event.calendarIds && event.calendarIds.length > 0) {
        const calendarId = event.calendarIds[0];
        const calendar = calendarCache.get(calendarId);
        if (calendar && calendar.color) {
          return calendar.color;
        }
      }

      // é»˜è®¤é¢œè‰²
      const colors = [
        '#F4C7AB', // æµ…æ©™
        '#C8D9C4', // æµ…ç»¿
        '#A8C8E1', // æµ…è“
        '#E8B4C8', // ç²‰è‰²
        '#D4C5E2', // ç´«è‰²
      ];

      // æ ¹æ®äº‹ä»¶æ ‡é¢˜å“ˆå¸Œé€‰æ‹©é¢œè‰²
      const title = event.title?.simpleTitle || '';
      const hash = title.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
      return colors[hash % colors.length];
    }

    function getEventName(event) {
      // ä¼˜å…ˆä½¿ç”¨æ—¥å†åç§°
      if (event.calendarIds && event.calendarIds.length > 0) {
        const calendarId = event.calendarIds[0];
        const calendar = calendarCache.get(calendarId);
        if (calendar && calendar.name) {
          return calendar.name;
        }
      }

      // ä½¿ç”¨æ ‡ç­¾æˆ–æ ‡é¢˜
      if (event.tags && event.tags.length > 0) {
        return event.tags[0];
      }

      return event.title?.simpleTitle || 'æœªå‘½å';
    }

    function renderTimeline(hourlyData) {
      const amTimeline = document.getElementById('amTimeline');
      const pmTimeline = document.getElementById('pmTimeline');

      amTimeline.innerHTML = '';
      pmTimeline.innerHTML = '';

      // ä¸Šåˆ 0-11
      for (let h = 0; h <= 11; h++) {
        const row = createHourRow(h, hourlyData[h]);
        amTimeline.appendChild(row);
      }

      // ä¸‹åˆ 12-23
      for (let h = 12; h < 24; h++) {
        const row = createHourRow(h, hourlyData[h]);
        pmTimeline.appendChild(row);
      }
    }

    function createHourRow(hour, blocks) {
      const row = document.createElement('div');
      row.className = 'hour-row';

      const label = document.createElement('div');
      label.className = 'hour-label';
      
      // æ ¼å¼åŒ–æ—¶é—´æ ‡ç­¾
      if (hour === 0) {
        label.textContent = '0/12';
      } else if (hour <= 11) {
        label.textContent = hour.toString();
      } else if (hour === 12) {
        label.textContent = '12';
      } else {
        label.textContent = (hour - 12).toString();
      }

      const container = document.createElement('div');
      container.className = 'hour-bar-container';

      if (!blocks || blocks.length === 0) {
        // ç©ºç™½å°æ—¶
        const emptyBar = document.createElement('div');
        emptyBar.className = 'hour-bar empty';
        emptyBar.style.width = '100%';
        container.appendChild(emptyBar);
      } else {
        // æœ‰äº‹ä»¶çš„å°æ—¶
        blocks.forEach(block => {
          const bar = document.createElement('div');
          bar.className = 'hour-bar';
          bar.style.backgroundColor = block.color;
          bar.style.width = `${(block.duration / 60) * 100}%`;
          bar.title = `${block.name} - ${block.duration}åˆ†é’Ÿ`;
          container.appendChild(bar);
        });
      }

      row.appendChild(label);
      row.appendChild(container);

      return row;
    }

    function renderPieChart(categoryStats) {
      const svg = document.getElementById('pieChart');
      const percentage = document.getElementById('piePercentage');
      
      svg.innerHTML = '';

      if (categoryStats.length === 0) {
        percentage.textContent = '0%';
        return;
      }

      const radius = 80;
      const innerRadius = 60;
      const centerX = 100;
      const centerY = 100;

      let currentAngle = 0;
      const totalMinutes = categoryStats.reduce((sum, stat) => sum + stat.minutes, 0);
      const totalHours = totalMinutes / 60;
      const busyPercentage = Math.round((totalMinutes / (24 * 60)) * 100);
      const gapAngle = 2; // è‰²å—ä¹‹é—´çš„é—´éš™è§’åº¦

      categoryStats.forEach(stat => {
        const angle = (stat.minutes / totalMinutes) * 360;
        const path = createArcPath(centerX, centerY, radius, innerRadius, currentAngle, currentAngle + angle - gapAngle);
        
        const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        pathElement.setAttribute('d', path);
        pathElement.setAttribute('fill', stat.color);
        pathElement.setAttribute('opacity', '0.9');
        
        svg.appendChild(pathElement);
        
        currentAngle += angle;
      });

      percentage.textContent = `${busyPercentage}%`;
    }

    function createArcPath(cx, cy, radius, innerRadius, startAngle, endAngle) {
      const startRad = (startAngle - 90) * Math.PI / 180;
      const endRad = (endAngle - 90) * Math.PI / 180;
      const cornerRadius = 12; // å¢å¤§åœ†è§’åŠå¾„ï¼Œæ›´åœ†æ¶¦

      const x1 = cx + radius * Math.cos(startRad);
      const y1 = cy + radius * Math.sin(startRad);
      const x2 = cx + radius * Math.cos(endRad);
      const y2 = cy + radius * Math.sin(endRad);

      const x3 = cx + innerRadius * Math.cos(endRad);
      const y3 = cy + innerRadius * Math.sin(endRad);
      const x4 = cx + innerRadius * Math.cos(startRad);
      const y4 = cy + innerRadius * Math.sin(startRad);

      const largeArc = endAngle - startAngle > 180 ? 1 : 0;

      // è®¡ç®—åœ†è§’çš„æ§åˆ¶ç‚¹ï¼Œä½¿ç”¨æ›´å¤§çš„åç§»åˆ›å»ºæ›´æ˜æ˜¾çš„åœ†è§’
      const outerCornerOffset = cornerRadius * 0.5522; // è´å¡å°”æ›²çº¿é­”æ•°ï¼Œè¿‘ä¼¼åœ†å½¢
      const innerCornerOffset = cornerRadius * 0.5522;

      // åˆ›å»ºå››ä¸ªåœ†è§’
      return `
        M ${x1 + cornerRadius * Math.cos(startRad)} ${y1 + cornerRadius * Math.sin(startRad)}
        L ${x2 - cornerRadius * Math.cos(endRad)} ${y2 - cornerRadius * Math.sin(endRad)}
        Q ${x2} ${y2} ${x2 + cornerRadius * Math.cos(endRad + Math.PI/2)} ${y2 + cornerRadius * Math.sin(endRad + Math.PI/2)}
        L ${x3 - cornerRadius * Math.cos(endRad + Math.PI/2)} ${y3 - cornerRadius * Math.sin(endRad + Math.PI/2)}
        Q ${x3} ${y3} ${x3 - cornerRadius * Math.cos(endRad)} ${y3 - cornerRadius * Math.sin(endRad)}
        A ${innerRadius} ${innerRadius} 0 ${largeArc} 0 ${x4 + cornerRadius * Math.cos(startRad)} ${y4 + cornerRadius * Math.sin(startRad)}
        Q ${x4} ${y4} ${x4 + cornerRadius * Math.cos(startRad - Math.PI/2)} ${y4 + cornerRadius * Math.sin(startRad - Math.PI/2)}
        L ${x1 - cornerRadius * Math.cos(startRad - Math.PI/2)} ${y1 - cornerRadius * Math.sin(startRad - Math.PI/2)}
        Q ${x1} ${y1} ${x1 + cornerRadius * Math.cos(startRad)} ${y1 + cornerRadius * Math.sin(startRad)}
        Z
      `;
    }

    function renderLegend(categoryStats) {
      const legend = document.getElementById('legend');
      legend.innerHTML = '';

      if (categoryStats.length === 0) {
        legend.innerHTML = '<div class="empty-state">æš‚æ— æ•°æ®</div>';
        return;
      }

      categoryStats.forEach(stat => {
        const item = document.createElement('div');
        item.className = 'legend-item';

        const left = document.createElement('div');
        left.className = 'legend-left';

        const color = document.createElement('div');
        color.className = 'legend-color';
        color.style.backgroundColor = stat.color;

        const name = document.createElement('div');
        name.className = 'legend-name';
        name.textContent = stat.name;

        const duration = document.createElement('div');
        duration.className = 'legend-duration';
        const hours = Math.floor(stat.minutes / 60);
        const minutes = Math.round(stat.minutes % 60);
        duration.textContent = hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;

        left.appendChild(color);
        left.appendChild(name);
        item.appendChild(left);
        item.appendChild(duration);
        legend.appendChild(item);
      });
    }

    function updateSummary(hourlyData, categoryStats) {
      const totalBusyMinutes = categoryStats.reduce((sum, stat) => sum + stat.minutes, 0);
      const totalFreeMinutes = 24 * 60 - totalBusyMinutes;

      const busyHours = Math.floor(totalBusyMinutes / 60);
      const busyMinutes = Math.round(totalBusyMinutes % 60);
      const freeHours = Math.floor(totalFreeMinutes / 60);
      const freeMinutes = Math.round(totalFreeMinutes % 60);

      document.getElementById('totalBusy').textContent = 
        busyHours > 0 ? `${busyHours}h ${busyMinutes}m` : `${busyMinutes}m`;
      document.getElementById('totalFree').textContent = 
        `${freeHours}h`;
    }

    // å¯åŠ¨åº”ç”¨
    init();
  </script>
</body>
</html>
