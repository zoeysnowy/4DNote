<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ¯æ—¥æ—¶é—´ç»Ÿè®¡ - Daily Time Stats</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
      padding: 20px;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      min-height: 100vh;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
      background: white;
      border-radius: 24px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .header {
      padding: 24px 32px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .header h1 {
      font-size: 24px;
      font-weight: 600;
    }

    .date-selector {
      display: flex;
      align-items: center;
      gap: 12px;
      background: rgba(255, 255, 255, 0.2);
      padding: 8px 16px;
      border-radius: 12px;
      backdrop-filter: blur(10px);
    }

    .date-selector input {
      background: transparent;
      border: none;
      color: white;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
    }

    .date-selector input::-webkit-calendar-picker-indicator {
      filter: invert(1);
      cursor: pointer;
    }

    .content {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1px;
      background: #e5e7eb;
    }

    .panel {
      background: white;
      padding: 32px;
    }

    .panel-title {
      font-size: 14px;
      font-weight: 600;
      color: #6b7280;
      margin-bottom: 20px;
      text-align: center;
    }

    /* å·¦ä¾§æ—¶é—´è½´æ ·å¼ */
    .timeline-container {
      display: flex;
      gap: 24px;
      align-items: center;
    }

    .timeline-section {
      flex: 1;
    }

    .timeline-header {
      font-size: 18px;
      font-weight: 600;
      color: #374151;
      margin-bottom: 16px;
      text-align: center;
    }

    .timeline-hours {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .hour-row {
      display: flex;
      align-items: center;
      gap: 8px;
      height: 24px;
    }

    .hour-label {
      font-size: 12px;
      color: #6b7280;
      font-weight: 500;
      min-width: 40px;
      text-align: right;
    }

    .hour-bar-container {
      flex: 1;
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .hour-bar {
      height: 20px;
      border-radius: 10px;
      transition: all 0.3s ease;
      position: relative;
      min-width: 8px;
    }

    .hour-bar:hover {
      transform: scaleY(1.2);
      filter: brightness(1.1);
      z-index: 10;
    }

    .hour-bar.empty {
      background: #f3f4f6;
      opacity: 0.5;
    }

    /* å³ä¾§é¥¼å›¾æ ·å¼ */
    .chart-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 24px;
    }

    .date-display {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 24px;
      font-weight: 600;
      color: #1f2937;
    }

    .date-nav {
      background: #f3f4f6;
      border: none;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
    }

    .date-nav:hover {
      background: #e5e7eb;
      transform: scale(1.1);
    }

    .pie-chart {
      position: relative;
      width: 200px;
      height: 200px;
    }

    .pie-chart svg {
      transform: rotate(-90deg);
    }

    .pie-percentage {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 36px;
      font-weight: 700;
      color: #1f2937;
    }

    .legend {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* Tooltipæ ·å¼ */
    .pie-tooltip {
      position: fixed;
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      pointer-events: none;
      z-index: 10000;
      opacity: 0;
      transition: opacity 0.2s;
      white-space: pre-line;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    .pie-tooltip.show {
      opacity: 1;
    }

    .legend-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      border-radius: 8px;
      transition: all 0.2s;
    }

    .legend-item:hover {
      background: #f9fafb;
      transform: translateX(4px);
    }

    .legend-left {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .legend-name {
      font-size: 14px;
      color: #374151;
      font-weight: 500;
    }

    .legend-duration {
      font-size: 14px;
      color: #6b7280;
      font-weight: 600;
    }

    .empty-state {
      text-align: center;
      color: #9ca3af;
      padding: 40px;
      font-size: 14px;
    }

    .stats-summary {
      display: flex;
      justify-content: space-around;
      padding: 16px;
      background: #f9fafb;
      border-radius: 12px;
      margin-top: 12px;
    }

    .stat-item {
      text-align: center;
    }

    .stat-value {
      font-size: 18px;
      font-weight: 700;
      color: #1f2937;
    }

    .stat-label {
      font-size: 12px;
      color: #6b7280;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <!-- Tooltipå…ƒç´  -->
  <div class="pie-tooltip" id="pieTooltip"></div>
  
  <div class="container">
    <div class="header">
      <h1>ğŸ“Š æ¯æ—¥æ—¶é—´ç»Ÿè®¡</h1>
      <div class="date-selector">
        <label for="dateInput">é€‰æ‹©æ—¥æœŸï¼š</label>
        <input type="date" id="dateInput" />
      </div>
    </div>

    <div class="content">
      <!-- å·¦ä¾§ï¼šæ—¶é—´è½´è§†å›¾ -->
      <div class="panel">
        <div class="timeline-container">
          <div class="timeline-section">
            <div class="timeline-header">ä¸Šåˆ</div>
            <div class="timeline-hours" id="amTimeline"></div>
          </div>
          <div class="timeline-section">
            <div class="timeline-header">ä¸‹åˆ</div>
            <div class="timeline-hours" id="pmTimeline"></div>
          </div>
        </div>
        
        <div class="stats-summary" id="totalStats">
          <div class="stat-item">
            <div class="stat-value" id="totalBusy">0h</div>
            <div class="stat-label">å·²å®‰æ’</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="totalFree">0h</div>
            <div class="stat-label">ç©ºç™½</div>
          </div>
        </div>
      </div>

      <!-- å³ä¾§ï¼šé¥¼å›¾ + åˆ†ç±»ç»Ÿè®¡ -->
      <div class="panel">
        <div class="chart-container">
          <div class="date-display">
            <button class="date-nav" id="prevDay">â—€</button>
            <span id="dateText">6æœˆ17æ—¥</span>
            <button class="date-nav" id="nextDay">â–¶</button>
          </div>

          <div class="pie-chart">
            <svg width="200" height="200" id="pieChart"></svg>
            <div class="pie-percentage" id="piePercentage">0%</div>
          </div>

          <div class="legend" id="legend"></div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import { EventService } from '../src/services/EventService.js';
    import { TagService } from '../src/services/TagService.js';

    let currentDate = new Date();
    let allEvents = [];
    let calendarCache = new Map();

    // åˆå§‹åŒ–
    async function init() {
      // è®¾ç½®é»˜è®¤æ—¥æœŸä¸ºä»Šå¤©
      const dateInput = document.getElementById('dateInput');
      dateInput.value = formatDateInput(currentDate);
      updateDateDisplay();

      // åŠ è½½æ—¥å†ç¼“å­˜
      const cacheStr = localStorage.getItem('calendarCache');
      if (cacheStr) {
        try {
          const cacheData = JSON.parse(cacheStr);
          calendarCache = new Map(cacheData.map(c => [c.id, c]));
        } catch (e) {
          console.warn('Failed to load calendar cache:', e);
        }
      }

      // åŠ è½½æ•°æ®
      await loadDayStats();

      // äº‹ä»¶ç›‘å¬
      dateInput.addEventListener('change', (e) => {
        currentDate = new Date(e.target.value);
        updateDateDisplay();
        loadDayStats();
      });

      document.getElementById('prevDay').addEventListener('click', () => {
        currentDate.setDate(currentDate.getDate() - 1);
        dateInput.value = formatDateInput(currentDate);
        updateDateDisplay();
        loadDayStats();
      });

      document.getElementById('nextDay').addEventListener('click', () => {
        currentDate.setDate(currentDate.getDate() + 1);
        dateInput.value = formatDateInput(currentDate);
        updateDateDisplay();
        loadDayStats();
      });
    }

    function formatDateInput(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    function updateDateDisplay() {
      const month = currentDate.getMonth() + 1;
      const day = currentDate.getDate();
      document.getElementById('dateText').textContent = `${month}æœˆ${day}æ—¥`;
    }

    async function loadDayStats() {
      try {
        // è·å–å½“å¤©çš„äº‹ä»¶
        allEvents = await EventService.getAllEvents();
        
        const dateStr = formatDateInput(currentDate);
        const dayEvents = allEvents.filter(event => {
          if (!event.startTime) return false;
          const eventDate = event.startTime.substring(0, 10);
          return eventDate === dateStr;
        });

        console.log(`Found ${dayEvents.length} events for ${dateStr}`);
        
        // ç»Ÿè®¡æ¯å°æ—¶çš„æ•°æ®
        const hourlyData = calculateHourlyData(dayEvents);
        
        // ç»Ÿè®¡åˆ†ç±»æ•°æ®
        const categoryStats = calculateCategoryStats(dayEvents);
        
        // æ¸²æŸ“è§†å›¾
        renderTimeline(hourlyData);
        renderPieChart(categoryStats);
        renderLegend(categoryStats);
        updateSummary(hourlyData, categoryStats);

      } catch (error) {
        console.error('Failed to load day stats:', error);
      }
    }

    function calculateHourlyData(events) {
      const hourlyData = {};
      
      // åˆå§‹åŒ– 0-23 å°æ—¶
      for (let h = 0; h < 24; h++) {
        hourlyData[h] = [];
      }

      events.forEach(event => {
        if (!event.startTime || !event.endTime) return;

        const start = new Date(event.startTime);
        const end = new Date(event.endTime);
        
        // è·å–äº‹ä»¶çš„é¢œè‰²
        const color = getEventColor(event);
        const name = getEventName(event);

        // è®¡ç®—è·¨è¶Šçš„å°æ—¶
        let currentHour = start.getHours();
        const endHour = end.getHours();
        const endMinute = end.getMinutes();

        while (currentHour <= endHour) {
          const hourStart = currentHour === start.getHours() ? start.getMinutes() : 0;
          const hourEnd = currentHour === endHour ? endMinute : 60;
          const duration = hourEnd - hourStart;

          if (duration > 0) {
            hourlyData[currentHour].push({
              duration,
              color,
              name,
              event
            });
          }

          currentHour++;
        }
      });

      return hourlyData;
    }

    function calculateCategoryStats(events) {
      const stats = new Map();
      let totalMinutes = 0;

      events.forEach(event => {
        if (!event.startTime || !event.endTime) return;

        const start = new Date(event.startTime);
        const end = new Date(event.endTime);
        const minutes = (end - start) / 1000 / 60;
        
        totalMinutes += minutes;

        const name = getEventName(event);
        const color = getEventColor(event);

        if (!stats.has(name)) {
          stats.set(name, {
            name,
            color,
            minutes: 0,
            count: 0
          });
        }

        const stat = stats.get(name);
        stat.minutes += minutes;
        stat.count++;
      });

      // è½¬æ¢ä¸ºæ•°ç»„å¹¶æ’åº
      const result = Array.from(stats.values())
        .sort((a, b) => b.minutes - a.minutes);

      result.forEach(stat => {
        stat.percentage = totalMinutes > 0 ? (stat.minutes / totalMinutes * 100) : 0;
      });

      return result;
    }

    function getEventColor(event) {
      // ä¼˜å…ˆä½¿ç”¨æ—¥å†é¢œè‰²
      if (event.calendarIds && event.calendarIds.length > 0) {
        const calendarId = event.calendarIds[0];
        const calendar = calendarCache.get(calendarId);
        if (calendar && calendar.color) {
          return calendar.color;
        }
      }

      // é»˜è®¤é¢œè‰²
      const colors = [
        '#F4C7AB', // æµ…æ©™
        '#C8D9C4', // æµ…ç»¿
        '#A8C8E1', // æµ…è“
        '#E8B4C8', // ç²‰è‰²
        '#D4C5E2', // ç´«è‰²
      ];

      // æ ¹æ®äº‹ä»¶æ ‡é¢˜å“ˆå¸Œé€‰æ‹©é¢œè‰²
      const title = event.title?.simpleTitle || '';
      const hash = title.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
      return colors[hash % colors.length];
    }

    function getEventName(event) {
      // ä¼˜å…ˆä½¿ç”¨æ—¥å†åç§°
      if (event.calendarIds && event.calendarIds.length > 0) {
        const calendarId = event.calendarIds[0];
        const calendar = calendarCache.get(calendarId);
        if (calendar && calendar.name) {
          return calendar.name;
        }
      }

      // ä½¿ç”¨æ ‡ç­¾æˆ–æ ‡é¢˜
      if (event.tags && event.tags.length > 0) {
        return event.tags[0];
      }

      return event.title?.simpleTitle || 'æœªå‘½å';
    }

    function renderTimeline(hourlyData) {
      const amTimeline = document.getElementById('amTimeline');
      const pmTimeline = document.getElementById('pmTimeline');

      amTimeline.innerHTML = '';
      pmTimeline.innerHTML = '';

      // ä¸Šåˆ 0-11
      for (let h = 0; h <= 11; h++) {
        const row = createHourRow(h, hourlyData[h]);
        amTimeline.appendChild(row);
      }

      // ä¸‹åˆ 12-23
      for (let h = 12; h < 24; h++) {
        const row = createHourRow(h, hourlyData[h]);
        pmTimeline.appendChild(row);
      }
    }

    function createHourRow(hour, blocks) {
      const row = document.createElement('div');
      row.className = 'hour-row';

      const label = document.createElement('div');
      label.className = 'hour-label';
      
      // æ ¼å¼åŒ–æ—¶é—´æ ‡ç­¾
      if (hour === 0) {
        label.textContent = '0/12';
      } else if (hour <= 11) {
        label.textContent = hour.toString();
      } else if (hour === 12) {
        label.textContent = '12';
      } else {
        label.textContent = (hour - 12).toString();
      }

      const container = document.createElement('div');
      container.className = 'hour-bar-container';

      if (!blocks || blocks.length === 0) {
        // ç©ºç™½å°æ—¶
        const emptyBar = document.createElement('div');
        emptyBar.className = 'hour-bar empty';
        emptyBar.style.width = '100%';
        container.appendChild(emptyBar);
      } else {
        // æœ‰äº‹ä»¶çš„å°æ—¶
        blocks.forEach(block => {
          const bar = document.createElement('div');
          bar.className = 'hour-bar';
          bar.style.backgroundColor = block.color;
          bar.style.width = `${(block.duration / 60) * 100}%`;
          bar.title = `${block.name} - ${block.duration}åˆ†é’Ÿ`;
          container.appendChild(bar);
        });
      }

      row.appendChild(label);
      row.appendChild(container);

      return row;
    }

    function renderPieChart(categoryStats) {
      const svg = document.getElementById('pieChart');
      const percentage = document.getElementById('piePercentage');
      
      svg.innerHTML = '';

      if (categoryStats.length === 0) {
        percentage.textContent = '0%';
        return;
      }

      const radius = 80;
      const innerRadius = 60;
      const centerX = 100;
      const centerY = 100;

      let currentAngle = 0;
      const totalMinutes = categoryStats.reduce((sum, stat) => sum + stat.minutes, 0);
      const totalHours = totalMinutes / 60;
      const busyPercentage = Math.round((totalMinutes / (24 * 60)) * 100);
      const gapAngle = 4; // è‰²å—ä¹‹é—´çš„é—´éš™è§’åº¦

      // è¿‡æ»¤æ‰å æ¯”å¤ªå°çš„è‰²å—ï¼ˆ<0.5%ï¼‰ï¼Œé¿å…æ¸²æŸ“é—®é¢˜
      const minPercentage = 0.5;
      const visibleStats = categoryStats.filter(stat => (stat.minutes / totalMinutes * 100) >= minPercentage);

      visibleStats.forEach((stat, index) => {
        const angle = (stat.minutes / totalMinutes) * 360;
        // é™¤äº†æœ€åä¸€ä¸ªè‰²å—ï¼Œå…¶ä»–éƒ½å‡å»é—´éš™è§’åº¦
        const endAngle = index === visibleStats.length - 1 ? currentAngle + angle : currentAngle + angle - gapAngle;
        
        // è®¡ç®—è‰²å—çš„å®é™…å¼§é•¿ï¼ˆå¤–åœ†ï¼‰
        const actualAngle = endAngle - currentAngle;
        const arcLength = (actualAngle * Math.PI / 180) * radius;
        
        // åœ†è§’åŠå¾„å¿…é¡»å°äºå¼§é•¿çš„ä¸€åŠ
        const maxCornerRadius = arcLength / 2;
        let cornerRadius = Math.min(10, maxCornerRadius * 0.8); // æœ€å¤šä½¿ç”¨å¼§é•¿çš„40%ï¼ˆä¸¤ç«¯å„20%ï¼‰
        
        // ç¡®ä¿æœ€å°åœ†è§’ä¸º2px
        cornerRadius = Math.max(2, cornerRadius);
        
        const path = createArcPath(centerX, centerY, radius, innerRadius, currentAngle, endAngle, cornerRadius);
        
        const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        pathElement.setAttribute('d', path);
        pathElement.setAttribute('fill', stat.color);
        pathElement.setAttribute('opacity', '0.9');
        pathElement.style.cursor = 'pointer';
        pathElement.style.transition = 'opacity 0.2s';
        
        // æ·»åŠ hoveræ•ˆæœå’Œtooltip
        const hours = Math.floor(stat.minutes / 60);
        const mins = Math.round(stat.minutes % 60);
        const timeStr = hours > 0 ? `${hours}h ${mins}m` : `${mins}m`;
        const tooltipText = `${stat.name}\n${timeStr}\n${(stat.minutes / totalMinutes * 100).toFixed(1)}%`;
        
        pathElement.addEventListener('mouseenter', function(e) {
          this.setAttribute('opacity', '1');
          showTooltip(e, tooltipText);
        });
        pathElement.addEventListener('mousemove', function(e) {
          updateTooltipPosition(e);
        });
        pathElement.addEventListener('mouseleave', function() {
          this.setAttribute('opacity', '0.9');
          hideTooltip();
        });
        
        svg.appendChild(pathElement);
        
        currentAngle += angle;
      });

      percentage.innerHTML = `
        <div style="font-size: 20px; font-weight: 700;">${Math.floor(totalHours)}h ${Math.round(totalMinutes % 60)}m</div>
        <div style="font-size: 11px; color: #999; margin-top: 2px;">${categoryStats.length} é¡¹</div>
      `;
    }

    function createArcPath(cx, cy, radius, innerRadius, startAngle, endAngle, cornerRadius = 10) {
      const startRad = (startAngle - 90) * Math.PI / 180;
      const endRad = (endAngle - 90) * Math.PI / 180;
      
      // è®¡ç®—åŸºç¡€ç«¯ç‚¹
      const outerStart = {
        x: cx + radius * Math.cos(startRad),
        y: cy + radius * Math.sin(startRad)
      };
      const outerEnd = {
        x: cx + radius * Math.cos(endRad),
        y: cy + radius * Math.sin(endRad)
      };
      const innerEnd = {
        x: cx + innerRadius * Math.cos(endRad),
        y: cy + innerRadius * Math.sin(endRad)
      };
      const innerStart = {
        x: cx + innerRadius * Math.cos(startRad),
        y: cy + innerRadius * Math.sin(startRad)
      };

      const largeArc = endAngle - startAngle > 180 ? 1 : 0;

      // è®¡ç®—åˆ‡å‘é‡æ–¹å‘ï¼ˆå‚ç›´äºåŠå¾„ï¼‰
      const startTangentX = -Math.sin(startRad);
      const startTangentY = Math.cos(startRad);
      const endTangentX = -Math.sin(endRad);
      const endTangentY = Math.cos(endRad);

      // åœ¨èµ·ç‚¹å’Œç»ˆç‚¹å¤„å‘å†…åç§»åœ†è§’è·ç¦»
      const outerStartOffset = {
        x: outerStart.x + cornerRadius * startTangentX,
        y: outerStart.y + cornerRadius * startTangentY
      };
      const innerStartOffset = {
        x: innerStart.x + cornerRadius * startTangentX,
        y: innerStart.y + cornerRadius * startTangentY
      };
      const outerEndOffset = {
        x: outerEnd.x - cornerRadius * endTangentX,
        y: outerEnd.y - cornerRadius * endTangentY
      };
      const innerEndOffset = {
        x: innerEnd.x - cornerRadius * endTangentX,
        y: innerEnd.y - cornerRadius * endTangentY
      };

      // è®¡ç®—å¾„å‘æ–¹å‘
      const startRadialX = Math.cos(startRad);
      const startRadialY = Math.sin(startRad);
      const endRadialX = Math.cos(endRad);
      const endRadialY = Math.sin(endRad);

      // å†…å¤–åœ†ä¹‹é—´è¿æ¥çº¿çš„åœ†è§’æ§åˆ¶ç‚¹
      const startOuterCorner = {
        x: outerStart.x - cornerRadius * startRadialX,
        y: outerStart.y - cornerRadius * startRadialY
      };
      const startInnerCorner = {
        x: innerStart.x + cornerRadius * startRadialX,
        y: innerStart.y + cornerRadius * startRadialY
      };
      const endOuterCorner = {
        x: outerEnd.x - cornerRadius * endRadialX,
        y: outerEnd.y - cornerRadius * endRadialY
      };
      const endInnerCorner = {
        x: innerEnd.x + cornerRadius * endRadialX,
        y: innerEnd.y + cornerRadius * endRadialY
      };

      return `
        M ${outerStartOffset.x} ${outerStartOffset.y}
        A ${radius} ${radius} 0 ${largeArc} 1 ${outerEndOffset.x} ${outerEndOffset.y}
        Q ${outerEnd.x} ${outerEnd.y} ${endOuterCorner.x} ${endOuterCorner.y}
        L ${endInnerCorner.x} ${endInnerCorner.y}
        Q ${innerEnd.x} ${innerEnd.y} ${innerEndOffset.x} ${innerEndOffset.y}
        A ${innerRadius} ${innerRadius} 0 ${largeArc} 0 ${innerStartOffset.x} ${innerStartOffset.y}
        Q ${innerStart.x} ${innerStart.y} ${startInnerCorner.x} ${startInnerCorner.y}
        L ${startOuterCorner.x} ${startOuterCorner.y}
        Q ${outerStart.x} ${outerStart.y} ${outerStartOffset.x} ${outerStartOffset.y}
        Z
      `;
    }

    function renderLegend(categoryStats) {
      const legend = document.getElementById('legend');
      legend.innerHTML = '';

      if (categoryStats.length === 0) {
        legend.innerHTML = '<div class="empty-state">æš‚æ— æ•°æ®</div>';
        return;
      }

      categoryStats.forEach(stat => {
        const item = document.createElement('div');
        item.className = 'legend-item';

        const left = document.createElement('div');
        left.className = 'legend-left';

        const color = document.createElement('div');
        color.className = 'legend-color';
        color.style.backgroundColor = stat.color;

        const name = document.createElement('div');
        name.className = 'legend-name';
        name.textContent = stat.name;

        const duration = document.createElement('div');
        duration.className = 'legend-duration';
        const hours = Math.floor(stat.minutes / 60);
        const minutes = Math.round(stat.minutes % 60);
        duration.textContent = hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;

        left.appendChild(color);
        left.appendChild(name);
        item.appendChild(left);
        item.appendChild(duration);
        legend.appendChild(item);
      });
    }

    function updateSummary(hourlyData, categoryStats) {
      const totalBusyMinutes = categoryStats.reduce((sum, stat) => sum + stat.minutes, 0);
      const totalFreeMinutes = 24 * 60 - totalBusyMinutes;

      const busyHours = Math.floor(totalBusyMinutes / 60);
      const busyMinutes = Math.round(totalBusyMinutes % 60);
      const freeHours = Math.floor(totalFreeMinutes / 60);
      const freeMinutes = Math.round(totalFreeMinutes % 60);

      document.getElementById('totalBusy').textContent = 
        busyHours > 0 ? `${busyHours}h ${busyMinutes}m` : `${busyMinutes}m`;
      document.getElementById('totalFree').textContent = 
        `${freeHours}h`;
    }

    // Tooltip è¾…åŠ©å‡½æ•°
    function showTooltip(event, text) {
      const tooltip = document.getElementById('pieTooltip');
      tooltip.textContent = text;
      tooltip.classList.add('show');
      updateTooltipPosition(event);
    }

    function updateTooltipPosition(event) {
      const tooltip = document.getElementById('pieTooltip');
      tooltip.style.left = (event.pageX + 15) + 'px';
      tooltip.style.top = (event.pageY + 15) + 'px';
    }

    function hideTooltip() {
      const tooltip = document.getElementById('pieTooltip');
      tooltip.classList.remove('show');
    }

    // Tooltip è¾…åŠ©å‡½æ•°
    function showTooltip(event, text) {
      const tooltip = document.getElementById('pieTooltip');
      tooltip.textContent = text;
      tooltip.classList.add('show');
      updateTooltipPosition(event);
    }

    function updateTooltipPosition(event) {
      const tooltip = document.getElementById('pieTooltip');
      tooltip.style.left = (event.pageX + 15) + 'px';
      tooltip.style.top = (event.pageY + 15) + 'px';
    }

    function hideTooltip() {
      const tooltip = document.getElementById('pieTooltip');
      tooltip.classList.remove('show');
    }

    // å¯åŠ¨åº”ç”¨
    init();
  </script>
</body>
</html>
