<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>äº‹ä»¶æŸ¥è¯¢å·¥å…·</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 20px;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    h1 {
      color: white;
      text-align: center;
      margin-bottom: 30px;
      font-size: 32px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
    }

    .section {
      background: white;
      border-radius: 12px;
      padding: 24px;
      margin-bottom: 20px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    h2 {
      color: #333;
      margin-bottom: 16px;
      font-size: 20px;
      border-bottom: 2px solid #667eea;
      padding-bottom: 8px;
    }

    .input-group {
      margin-bottom: 16px;
      display: grid;
      grid-template-columns: 150px 1fr;
      gap: 10px;
      align-items: center;
    }

    label {
      color: #555;
      font-weight: 500;
    }

    input {
      padding: 10px;
      border: 2px solid #e0e0e0;
      border-radius: 6px;
      font-size: 14px;
    }

    input:focus {
      outline: none;
      border-color: #667eea;
    }

    button {
      background: #667eea;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.3s;
      margin-right: 10px;
    }

    button:hover {
      background: #5568d3;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .output {
      background: #f8f9fa;
      border: 2px solid #e0e0e0;
      border-radius: 6px;
      padding: 16px;
      margin-top: 16px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      white-space: pre-wrap;
      word-break: break-all;
      max-height: 600px;
      overflow-y: auto;
    }

    .success {
      background: #d4edda;
      border-color: #28a745;
      color: #155724;
    }

    .error {
      background: #f8d7da;
      border-color: #dc3545;
      color: #721c24;
    }

    .warning {
      background: #fff3cd;
      border-color: #ffc107;
      color: #856404;
    }

    .info {
      background: #d1ecf1;
      border-color: #17a2b8;
      color: #0c5460;
    }

    .event-card {
      background: white;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      padding: 16px;
      margin: 12px 0;
      cursor: pointer;
      transition: all 0.3s;
    }

    .event-card:hover {
      border-color: #667eea;
      box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
    }

    .event-card.selected {
      border-color: #667eea;
      background: #f0f4ff;
    }

    .event-title {
      font-weight: 600;
      color: #333;
      margin-bottom: 8px;
      font-size: 16px;
    }

    .event-meta {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 8px;
      font-size: 13px;
      color: #666;
    }

    .event-meta-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
    }

    .badge-success {
      background: #d4edda;
      color: #155724;
    }

    .badge-warning {
      background: #fff3cd;
      color: #856404;
    }

    .badge-info {
      background: #d1ecf1;
      color: #0c5460;
    }

    .copy-btn {
      background: #28a745;
      padding: 6px 12px;
      font-size: 12px;
      margin-left: 10px;
    }

    .copy-btn:hover {
      background: #218838;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ” äº‹ä»¶ç²¾ç¡®æŸ¥è¯¢å·¥å…·</h1>

    <div class="section">
      <h2>æŒ‰æ—¥æœŸå’Œæ—¶é—´æŸ¥è¯¢</h2>
      <div class="input-group">
        <label>æ—¥æœŸ:</label>
        <input type="date" id="eventDate" value="2025-12-14">
      </div>
      <div class="input-group">
        <label>å¼€å§‹æ—¶é—´:</label>
        <input type="time" id="startTime" value="17:30">
      </div>
      <div class="input-group">
        <label>æ ‡é¢˜å…³é”®è¯ï¼ˆå¯é€‰ï¼‰:</label>
        <input type="text" id="titleKeyword" placeholder="ä¾‹å¦‚: 4DNote">
      </div>
      <button onclick="searchByDateTime()">ğŸ” ç²¾ç¡®æŸ¥è¯¢</button>
      <button onclick="searchByDate()">ğŸ“… æŸ¥è¯¢å½“å¤©æ‰€æœ‰äº‹ä»¶</button>
      <button onclick="clearOutput()">æ¸…ç©º</button>
      <div id="output" class="output" style="display: none;"></div>
    </div>

    <div class="section">
      <h2>æŸ¥è¯¢æ•°æ®åº“ç»Ÿè®¡</h2>
      <button onclick="showDatabaseStats()">ğŸ“Š æ˜¾ç¤ºç»Ÿè®¡</button>
      <button onclick="cleanupEmptyDatabases()" style="background: #f44336; margin-left: 10px;">ğŸ—‘ï¸ æ¸…ç†ç©ºæ•°æ®åº“</button>
      <div id="statsOutput" class="output" style="display: none;"></div>
    </div>
  </div>

  <script>
    let selectedEventId = null;

    async function listAllDatabases() {
      if ('databases' in indexedDB) {
        const databases = await indexedDB.databases();
        console.log('ğŸ“‹ æ‰€æœ‰æ•°æ®åº“:', databases);
        return databases;
      }
      return [];
    }

    async function openDB() {
      return new Promise(async (resolve, reject) => {
        // å…ˆåˆ—å‡ºæ‰€æœ‰æ•°æ®åº“
        const databases = await listAllDatabases();
        console.log('ğŸ” æ£€æµ‹åˆ°çš„æ•°æ®åº“:', databases);
        
        // å°è¯•æ‰€æœ‰æ£€æµ‹åˆ°çš„æ•°æ®åº“ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªæœ‰å†…å®¹çš„
        if (databases && databases.length > 0) {
          for (const dbInfo of databases) {
            try {
              console.log(`ğŸ” å°è¯•æ‰“å¼€æ•°æ®åº“: ${dbInfo.name}`);
              const db = await new Promise((res, rej) => {
                const request = indexedDB.open(dbInfo.name);
                request.onsuccess = () => res(request.result);
                request.onerror = () => rej(request.error);
              });
              
              if (db.objectStoreNames.length > 0) {
                console.log('âœ… æ‰¾åˆ°æœ‰å†…å®¹çš„æ•°æ®åº“:', {
                  name: db.name,
                  version: db.version,
                  stores: Array.from(db.objectStoreNames)
                });
                resolve(db);
                return;
              } else {
                console.log(`â­ï¸ è·³è¿‡ç©ºæ•°æ®åº“: ${dbInfo.name}`);
                db.close();
              }
            } catch (err) {
              console.warn(`âš ï¸ æ— æ³•æ‰“å¼€æ•°æ®åº“ ${dbInfo.name}:`, err);
            }
          }
          
          reject(new Error('æ‰€æœ‰æ•°æ®åº“éƒ½æ˜¯ç©ºçš„ï¼Œè¯·å…ˆåœ¨åº”ç”¨ä¸­åˆ›å»ºäº‹ä»¶'));
          return;
        }
        
        // å¦‚æœæ— æ³•è·å–æ•°æ®åº“åˆ—è¡¨ï¼Œå°è¯•é»˜è®¤åç§°
        console.log('âš ï¸ æ— æ³•è·å–æ•°æ®åº“åˆ—è¡¨ï¼Œå°è¯•é»˜è®¤åç§°');
        const possibleDBNames = ['4DNoteDB', '4DNote', 'FourDNote'];
        
        for (const dbName of possibleDBNames) {
          try {
            const db = await new Promise((res, rej) => {
              const request = indexedDB.open(dbName);
              request.onsuccess = () => res(request.result);
              request.onerror = () => rej(request.error);
            });
            
            if (db.objectStoreNames.length > 0) {
              console.log('âœ… æ•°æ®åº“æ‰“å¼€æˆåŠŸ:', {
                name: db.name,
                version: db.version,
                stores: Array.from(db.objectStoreNames)
              });
              resolve(db);
              return;
            } else {
              db.close();
            }
          } catch (err) {
            console.warn(`å°è¯• ${dbName} å¤±è´¥:`, err);
          }
        }
        
        reject(new Error('æœªæ‰¾åˆ°å¯ç”¨çš„æ•°æ®åº“'));
      });
    }

    async function findEventStore(db) {
      const storeNames = Array.from(db.objectStoreNames);
      console.log('ğŸ“¦ å¯ç”¨çš„ Object Stores:', storeNames);
      
      if (storeNames.length === 0) {
        throw new Error('æ•°æ®åº“ä¸­æ²¡æœ‰ä»»ä½• object storeã€‚è¯·å…ˆåœ¨åº”ç”¨ä¸­åˆ›å»ºäº‹ä»¶ã€‚');
      }
      
      // å¯èƒ½çš„äº‹ä»¶å­˜å‚¨åç§°
      const possibleNames = ['events', 'Events', 'event', 'Event', 'event_store', 'EventStore'];
      
      for (const name of possibleNames) {
        if (storeNames.includes(name)) {
          console.log('âœ… æ‰¾åˆ°äº‹ä»¶å­˜å‚¨:', name);
          return name;
        }
      }
      
      // æŸ¥æ‰¾åŒ…å« 'event' çš„å­˜å‚¨
      const eventStore = storeNames.find(name => name.toLowerCase().includes('event'));
      if (eventStore) {
        console.log('âœ… æ‰¾åˆ°å¯èƒ½çš„äº‹ä»¶å­˜å‚¨:', eventStore);
        return eventStore;
      }
      
      // å¦‚æœåªæœ‰ä¸€ä¸ª storeï¼Œå°±ç”¨å®ƒ
      if (storeNames.length === 1) {
        console.log('âš ï¸ åªæœ‰ä¸€ä¸ª storeï¼Œå°è¯•ä½¿ç”¨:', storeNames[0]);
        return storeNames[0];
      }
      
      throw new Error(`æœªæ‰¾åˆ°äº‹ä»¶å­˜å‚¨ã€‚å¯ç”¨çš„ stores: ${storeNames.join(', ')}ã€‚\n\nè¯·æ£€æŸ¥:\n1. æ˜¯å¦å·²ç»åœ¨åº”ç”¨ä¸­åˆ›å»ºäº†äº‹ä»¶ï¼Ÿ\n2. æ•°æ®åº“æ˜¯å¦å·²ç»åˆå§‹åŒ–ï¼Ÿ`);
    }

    async function getAllEvents(db) {
      const storeName = await findEventStore(db);
      return new Promise((resolve, reject) => {
        const tx = db.transaction([storeName], 'readonly');
        const store = tx.objectStore(storeName);
        const request = store.getAll();
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    function formatDateTime(dateStr) {
      if (!dateStr) return 'N/A';
      const date = new Date(dateStr);
      if (isNaN(date.getTime())) return dateStr;
      return date.toLocaleString('zh-CN', { 
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });
    }

    function createEventCard(event, index) {
      const div = document.createElement('div');
      div.className = 'event-card';
      div.onclick = () => selectEvent(event.id, div);
      
      const title = typeof event.title === 'object' 
        ? (event.title.simpleTitle || event.title.fullTitle || 'æ— æ ‡é¢˜')
        : (event.title || 'æ— æ ‡é¢˜');
      
      const startDate = event.startTime ? new Date(event.startTime) : null;
      const endDate = event.endTime ? new Date(event.endTime) : null;
      
      let timeStr = '';
      if (startDate && !isNaN(startDate.getTime())) {
        const dateStr = startDate.toLocaleDateString('zh-CN');
        const startTimeStr = startDate.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
        const endTimeStr = endDate && !isNaN(endDate.getTime()) 
          ? endDate.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' })
          : '?';
        timeStr = `${dateStr} ${startTimeStr} - ${endTimeStr}`;
      } else {
        timeStr = 'æ— æ—¶é—´';
      }
      
      div.innerHTML = `
        <div class="event-title">${index + 1}. ${title}</div>
        <div class="event-meta">
          <div class="event-meta-item">
            ğŸ“… ${timeStr}
          </div>
          <div class="event-meta-item">
            ğŸ†” <code>${event.id}</code>
            <button class="copy-btn" onclick="event.stopPropagation(); copyToClipboard('${event.id}', this)">å¤åˆ¶ID</button>
          </div>
          <div class="event-meta-item">
            ğŸ“ åˆ›å»º: ${formatDateTime(event.createdAt)}
          </div>
          <div class="event-meta-item">
            ğŸ”„ æ›´æ–°: ${formatDateTime(event.updatedAt)}
          </div>
          <div class="event-meta-item">
            ğŸ·ï¸ ${event.tags && event.tags.length > 0 ? event.tags.join(', ') : 'æ— æ ‡ç­¾'}
          </div>
          <div class="event-meta-item">
            ğŸ”— æ¥æº: <span class="badge badge-info">${event.source || 'N/A'}</span>
          </div>
        </div>
      `;
      
      return div;
    }

    function selectEvent(eventId, cardElement) {
      selectedEventId = eventId;
      document.querySelectorAll('.event-card').forEach(card => {
        card.classList.remove('selected');
      });
      cardElement.classList.add('selected');
      
      console.log('âœ… å·²é€‰æ‹©äº‹ä»¶:', eventId);
      showEventDetails(eventId);
    }

    async function showEventDetails(eventId) {
      const output = document.getElementById('output');
      
      try {
        const db = await openDB();
        const storeName = await findEventStore(db);
        const tx = db.transaction([storeName], 'readonly');
        const store = tx.objectStore(storeName);
        const request = store.get(eventId);
        
        request.onsuccess = () => {
          const event = request.result;
          if (!event) {
            alert('äº‹ä»¶æœªæ‰¾åˆ°ï¼');
            return;
          }
          
          let details = `\n${'='.repeat(60)}\n`;
          details += `ğŸ“‹ äº‹ä»¶è¯¦ç»†ä¿¡æ¯\n`;
          details += `${'='.repeat(60)}\n\n`;
          details += `ğŸ†” ID: ${event.id}\n`;
          details += `ğŸ“ æ ‡é¢˜: ${typeof event.title === 'object' ? event.title.simpleTitle : event.title}\n`;
          details += `ğŸ“… å¼€å§‹æ—¶é—´: ${event.startTime}\n`;
          details += `â° ç»“æŸæ—¶é—´: ${event.endTime}\n`;
          details += `ğŸ¨ åˆ›å»ºæ—¶é—´: ${event.createdAt}\n`;
          details += `ğŸ”„ æ›´æ–°æ—¶é—´: ${event.updatedAt}\n`;
          details += `ğŸ”— æ¥æº: ${event.source}\n`;
          details += `ğŸ·ï¸ æ ‡ç­¾: ${event.tags ? event.tags.join(', ') : 'æ— '}\n\n`;
          
          // EventLog åˆ†æ
          details += `${'='.repeat(60)}\n`;
          details += `ğŸ“„ EventLog åˆ†æ\n`;
          details += `${'='.repeat(60)}\n`;
          
          let eventlog = event.eventlog;
          if (typeof eventlog === 'string') {
            try {
              eventlog = JSON.parse(eventlog);
              details += `ç±»å‹: string â†’ object âœ…\n`;
            } catch (e) {
              details += `ç±»å‹: stringï¼ˆè§£æå¤±è´¥ï¼‰âŒ\n`;
            }
          }
          
          if (eventlog && eventlog.slateJson) {
            let slateJson = eventlog.slateJson;
            if (typeof slateJson === 'string') {
              try {
                slateJson = JSON.parse(slateJson);
                details += `slateJson: string â†’ array âœ…\n`;
              } catch (e) {
                details += `slateJson: stringï¼ˆè§£æå¤±è´¥ï¼‰âŒ\n`;
              }
            }
            
            if (Array.isArray(slateJson)) {
              details += `èŠ‚ç‚¹æ•°: ${slateJson.length}\n\n`;
              
              slateJson.forEach((node, i) => {
                details += `  èŠ‚ç‚¹ ${i + 1}:\n`;
                details += `    ç±»å‹: ${node.type}\n`;
                
                if (node.createdAt) {
                  const date = new Date(node.createdAt);
                  details += `    âœ… createdAt: ${node.createdAt}\n`;
                  details += `       â†’ UTC: ${date.toISOString()}\n`;
                  details += `       â†’ æœ¬åœ°: ${date.toLocaleString('zh-CN')}\n`;
                } else {
                  details += `    âš ï¸ createdAt: ç¼ºå¤±\n`;
                }
                
                if (node.updatedAt) {
                  const date = new Date(node.updatedAt);
                  details += `    âœ… updatedAt: ${node.updatedAt}\n`;
                  details += `       â†’ æœ¬åœ°: ${date.toLocaleString('zh-CN')}\n`;
                }
                
                if (node.children) {
                  const text = node.children.map(c => c.text || '').join('');
                  details += `    å†…å®¹: ${text.substring(0, 100)}${text.length > 100 ? '...' : ''}\n`;
                }
                details += `\n`;
              });
            }
          }
          
          // Description
          if (event.description) {
            details += `\n${'='.repeat(60)}\n`;
            details += `ğŸ“ Description\n`;
            details += `${'='.repeat(60)}\n`;
            details += event.description.substring(0, 500);
            if (event.description.length > 500) {
              details += '\n...(å·²æˆªæ–­)';
            }
          }
          
          const newOutput = document.createElement('div');
          newOutput.textContent = details;
          newOutput.className = 'output info';
          newOutput.style.display = 'block';
          
          output.parentNode.insertBefore(newOutput, output.nextSibling);
        };
      } catch (error) {
        alert('æŸ¥è¯¢å¤±è´¥: ' + error.message);
      }
    }

    async function searchByDateTime() {
      const date = document.getElementById('eventDate').value;
      const time = document.getElementById('startTime').value;
      const keyword = document.getElementById('titleKeyword').value;
      const output = document.getElementById('output');
      
      output.style.display = 'block';
      output.innerHTML = '';
      output.className = 'output info';
      
      try {
        const db = await openDB();
        const events = await getAllEvents(db);
        
        const targetDateTime = new Date(`${date}T${time}`);
        console.log('ğŸ” æŸ¥è¯¢ç›®æ ‡æ—¶é—´:', targetDateTime.toLocaleString('zh-CN'));
        
        const matches = events.filter(event => {
          if (!event.startTime) return false;
          
          const startTime = new Date(event.startTime);
          if (isNaN(startTime.getTime())) return false;
          
          // æ£€æŸ¥æ—¥æœŸå’Œå°æ—¶ã€åˆ†é’Ÿæ˜¯å¦åŒ¹é…
          const dateMatch = 
            startTime.getFullYear() === targetDateTime.getFullYear() &&
            startTime.getMonth() === targetDateTime.getMonth() &&
            startTime.getDate() === targetDateTime.getDate() &&
            startTime.getHours() === targetDateTime.getHours() &&
            startTime.getMinutes() === targetDateTime.getMinutes();
          
          if (!dateMatch) return false;
          
          // å¦‚æœæœ‰å…³é”®è¯ï¼Œæ£€æŸ¥æ ‡é¢˜
          if (keyword) {
            const title = typeof event.title === 'object' 
              ? (event.title.simpleTitle || event.title.fullTitle || '')
              : (event.title || '');
            return title.includes(keyword);
          }
          
          return true;
        });
        
        if (matches.length === 0) {
          output.textContent = `âŒ æœªæ‰¾åˆ°åŒ¹é…çš„äº‹ä»¶\n\næŸ¥è¯¢æ¡ä»¶:\n  æ—¥æœŸæ—¶é—´: ${targetDateTime.toLocaleString('zh-CN')}\n  å…³é”®è¯: ${keyword || 'æ— '}`;
          output.className = 'output warning';
          return;
        }
        
        const header = document.createElement('div');
        header.textContent = `âœ… æ‰¾åˆ° ${matches.length} ä¸ªåŒ¹é…çš„äº‹ä»¶\n\næŸ¥è¯¢: ${targetDateTime.toLocaleString('zh-CN')}${keyword ? ` + "${keyword}"` : ''}\n`;
        output.appendChild(header);
        
        matches.forEach((event, index) => {
          output.appendChild(createEventCard(event, index));
        });
        
        output.className = 'output success';
        
      } catch (error) {
        output.textContent = `âŒ æŸ¥è¯¢å¤±è´¥:\n${error.message}\n\n${error.stack}`;
        output.className = 'output error';
      }
    }

    async function searchByDate() {
      const date = document.getElementById('eventDate').value;
      const output = document.getElementById('output');
      
      output.style.display = 'block';
      output.innerHTML = '';
      output.className = 'output info';
      
      try {
        const db = await openDB();
        const events = await getAllEvents(db);
        
        const targetDate = new Date(date);
        
        const matches = events.filter(event => {
          if (!event.startTime) return false;
          const startTime = new Date(event.startTime);
          if (isNaN(startTime.getTime())) return false;
          
          return startTime.getFullYear() === targetDate.getFullYear() &&
                 startTime.getMonth() === targetDate.getMonth() &&
                 startTime.getDate() === targetDate.getDate();
        });
        
        matches.sort((a, b) => new Date(a.startTime).getTime() - new Date(b.startTime).getTime());
        
        if (matches.length === 0) {
          output.textContent = `âŒ ${date} æ²¡æœ‰äº‹ä»¶`;
          output.className = 'output warning';
          return;
        }
        
        const header = document.createElement('div');
        header.textContent = `âœ… ${date} å…±æœ‰ ${matches.length} ä¸ªäº‹ä»¶\n\n`;
        output.appendChild(header);
        
        matches.forEach((event, index) => {
          output.appendChild(createEventCard(event, index));
        });
        
        output.className = 'output success';
        
      } catch (error) {
        output.textContent = `âŒ æŸ¥è¯¢å¤±è´¥:\n${error.message}`;
        output.className = 'output error';
      }
    }

    async function showDatabaseStats() {
      const output = document.getElementById('statsOutput');
      output.style.display = 'block';
      
      try {
        // å…ˆåˆ—å‡ºæ‰€æœ‰æ•°æ®åº“
        const databases = await listAllDatabases();
        
        let stats = `ğŸ“Š IndexedDB ç»Ÿè®¡\n\n`;
        
        if (databases && databases.length > 0) {
          stats += `æ£€æµ‹åˆ°çš„æ•°æ®åº“:\n`;
          databases.forEach(db => {
            stats += `  - ${db.name} (ç‰ˆæœ¬ ${db.version || 'unknown'})\n`;
          });
          stats += `\n`;
        }
        
        const db = await openDB();
        const storeNames = Array.from(db.objectStoreNames);
        
        stats += `å½“å‰æ•°æ®åº“: ${db.name}\n`;
        stats += `ç‰ˆæœ¬: ${db.version}\n`;
        stats += `Object Stores (${storeNames.length}):\n`;
        storeNames.forEach(name => {
          stats += `  - ${name}\n`;
        });
        
        output.textContent = stats;
      } catch (err) {
        output.textContent = 'âŒ é”™è¯¯: ' + err.message;
      }
    }

    async function cleanupEmptyDatabases() {
      const output = document.getElementById('statsOutput');
      output.style.display = 'block';
      
      try {
        const databases = await listAllDatabases();
        if (!databases || databases.length === 0) {
          output.textContent = 'âš ï¸ æ— æ³•è·å–æ•°æ®åº“åˆ—è¡¨';
          return;
        }

        output.textContent = 'ğŸ” æ­£åœ¨æ£€æŸ¥æ•°æ®åº“...\n';
        const emptyDatabases = [];
        
        // æ£€æŸ¥æ¯ä¸ªæ•°æ®åº“
        for (const dbInfo of databases) {
          try {
            const db = await new Promise((resolve, reject) => {
              const request = indexedDB.open(dbInfo.name);
              request.onsuccess = () => resolve(request.result);
              request.onerror = () => reject(request.error);
            });
            
            if (db.objectStoreNames.length === 0) {
              emptyDatabases.push(dbInfo.name);
              output.textContent += `  - å‘ç°ç©ºæ•°æ®åº“: ${dbInfo.name}\n`;
            }
            db.close();
          } catch (err) {
            console.warn(`æ— æ³•æ£€æŸ¥æ•°æ®åº“ ${dbInfo.name}:`, err);
          }
        }

        if (emptyDatabases.length === 0) {
          output.textContent = 'âœ… æ²¡æœ‰ç©ºæ•°æ®åº“éœ€è¦æ¸…ç†';
          return;
        }

        const confirmed = confirm(
          `å‘ç° ${emptyDatabases.length} ä¸ªç©ºæ•°æ®åº“:\n${emptyDatabases.join(', ')}\n\nç¡®å®šè¦åˆ é™¤å—ï¼Ÿ`
        );

        if (!confirmed) {
          output.textContent = 'âŒ å·²å–æ¶ˆ';
          return;
        }

        output.textContent = 'ğŸ—‘ï¸ æ­£åœ¨åˆ é™¤...\n';
        
        // åˆ é™¤ç©ºæ•°æ®åº“
        for (const dbName of emptyDatabases) {
          try {
            await new Promise((resolve, reject) => {
              const request = indexedDB.deleteDatabase(dbName);
              request.onsuccess = () => resolve();
              request.onerror = () => reject(request.error);
            });
            output.textContent += `  âœ… å·²åˆ é™¤: ${dbName}\n`;
          } catch (err) {
            output.textContent += `  âŒ åˆ é™¤å¤±è´¥ ${dbName}: ${err.message}\n`;
          }
        }

        output.textContent += '\nâœ… æ¸…ç†å®Œæˆï¼';
      } catch (err) {
        output.textContent = 'âŒ æ¸…ç†å¤±è´¥: ' + err.message;
      }
    }

    function copyToClipboard(text, button) {
      navigator.clipboard.writeText(text).then(() => {
        const originalText = button.textContent;
        button.textContent = 'âœ… å·²å¤åˆ¶';
        button.style.background = '#28a745';
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = '';
        }, 2000);
      }).catch(err => {
        alert('å¤åˆ¶å¤±è´¥: ' + err.message);
      });
    }

    function clearOutput() {
      document.getElementById('output').style.display = 'none';
      document.getElementById('output').innerHTML = '';
    }

    console.log('ğŸš€ äº‹ä»¶æŸ¥è¯¢å·¥å…·å·²åŠ è½½');
  </script>
</body>
</html>
