<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Block-Level Timestamp è°ƒè¯•å·¥å…·</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 20px;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    h1 {
      color: white;
      text-align: center;
      margin-bottom: 30px;
      font-size: 32px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
    }

    .test-section {
      background: white;
      border-radius: 12px;
      padding: 24px;
      margin-bottom: 20px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    h2 {
      color: #333;
      margin-bottom: 16px;
      font-size: 20px;
      border-bottom: 2px solid #667eea;
      padding-bottom: 8px;
    }

    h3 {
      color: #555;
      margin: 16px 0 8px;
      font-size: 16px;
    }

    .input-group {
      margin-bottom: 16px;
    }

    label {
      display: block;
      margin-bottom: 6px;
      color: #555;
      font-weight: 500;
    }

    textarea {
      width: 100%;
      min-height: 120px;
      padding: 12px;
      border: 2px solid #e0e0e0;
      border-radius: 6px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      resize: vertical;
      transition: border-color 0.3s;
    }

    textarea:focus {
      outline: none;
      border-color: #667eea;
    }

    button {
      background: #667eea;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.3s;
      margin-right: 10px;
    }

    button:hover {
      background: #5568d3;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    button:active {
      transform: translateY(0);
    }

    .output {
      background: #f8f9fa;
      border: 2px solid #e0e0e0;
      border-radius: 6px;
      padding: 16px;
      margin-top: 16px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      white-space: pre-wrap;
      word-break: break-all;
      max-height: 500px;
      overflow-y: auto;
    }

    .success {
      background: #d4edda;
      border-color: #28a745;
      color: #155724;
    }

    .error {
      background: #f8d7da;
      border-color: #dc3545;
      color: #721c24;
    }

    .warning {
      background: #fff3cd;
      border-color: #ffc107;
      color: #856404;
    }

    .info {
      background: #d1ecf1;
      border-color: #17a2b8;
      color: #0c5460;
    }

    .test-case {
      background: #f8f9fa;
      border-left: 4px solid #667eea;
      padding: 12px;
      margin-bottom: 12px;
      border-radius: 4px;
    }

    .test-case-title {
      font-weight: 600;
      color: #333;
      margin-bottom: 8px;
    }

    .test-result {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 12px;
      margin-top: 8px;
    }

    .result-item {
      background: white;
      padding: 10px;
      border-radius: 4px;
      border: 1px solid #e0e0e0;
    }

    .result-label {
      font-weight: 600;
      color: #667eea;
      font-size: 12px;
      margin-bottom: 4px;
    }

    .result-value {
      color: #333;
      font-size: 13px;
      word-break: break-all;
    }

    .timestamp-comparison {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 8px 0;
    }

    .timestamp-box {
      flex: 1;
      padding: 10px;
      border-radius: 4px;
      text-align: center;
    }

    .timestamp-original {
      background: #e3f2fd;
      border: 2px solid #2196f3;
    }

    .timestamp-parsed {
      background: #f3e5f5;
      border: 2px solid #9c27b0;
    }

    .timestamp-final {
      background: #e8f5e9;
      border: 2px solid #4caf50;
    }

    .arrow {
      font-size: 24px;
      color: #999;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    @media (max-width: 768px) {
      .grid-2 {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ” Block-Level Timestamp è°ƒè¯•å·¥å…·</h1>

    <!-- æµ‹è¯•åŒºåŸŸ 1: è‡ªå®šä¹‰è¾“å…¥ -->
    <div class="test-section">
      <h2>1ï¸âƒ£ è‡ªå®šä¹‰æ–‡æœ¬è§£ææµ‹è¯•</h2>
      <div class="input-group">
        <label for="customInput">è¾“å…¥åŒ…å«æ—¶é—´æˆ³çš„æ–‡æœ¬ï¼ˆæ”¯æŒå¤šè¡Œï¼Œæ¯è¡Œå¯ä»¥æ˜¯æ—¶é—´æˆ³æˆ–å†…å®¹ï¼‰ï¼š</label>
        <textarea id="customInput" placeholder="ä¾‹å¦‚ï¼š
2025-12-15 13:56:36
è¿™æ˜¯ç¬¬ä¸€æ®µå†…å®¹

2025-12-15 14:30:00
è¿™æ˜¯ç¬¬äºŒæ®µå†…å®¹">2025-12-15 13:56:36
è¿™æ˜¯ç¬¬ä¸€æ®µå†…å®¹

2025-12-15 14:30:00 è¿™è¡Œæœ‰æ—¶é—´æˆ³å’Œå†…å®¹
åç»­è¡Œå†…å®¹

2025-12-17 22:21:41
ç¬¬ä¸‰æ®µ</textarea>
      </div>
      <button onclick="testCustomInput()">è§£æå¹¶æ˜¾ç¤ºç»“æœ</button>
      <button onclick="clearCustomOutput()">æ¸…ç©ºç»“æœ</button>
      <div id="customOutput" class="output" style="display: none;"></div>
    </div>

    <!-- æµ‹è¯•åŒºåŸŸ 2: é¢„è®¾æµ‹è¯•ç”¨ä¾‹ -->
    <div class="test-section">
      <h2>2ï¸âƒ£ é¢„è®¾æµ‹è¯•ç”¨ä¾‹</h2>
      <button onclick="runAllTests()">è¿è¡Œæ‰€æœ‰æµ‹è¯•</button>
      <button onclick="clearTestOutput()">æ¸…ç©ºç»“æœ</button>
      <div id="testOutput" class="output" style="display: none;"></div>
    </div>

    <!-- æµ‹è¯•åŒºåŸŸ 3: EventLog å®Œæ•´æµ‹è¯• -->
    <div class="test-section">
      <h2>3ï¸âƒ£ EventLog â†’ EventNode å®Œæ•´æµç¨‹æµ‹è¯•</h2>
      <div class="input-group">
        <label for="eventLogInput">è¾“å…¥ EventLog slateJsonï¼ˆJSON æ ¼å¼ï¼‰ï¼š</label>
        <textarea id="eventLogInput" placeholder='ä¾‹å¦‚ï¼š
[
  {
    "type": "paragraph",
    "createdAt": 1734440196000,
    "updatedAt": 1734440215000,
    "children": [{"text": "æµ‹è¯•å†…å®¹"}]
  }
]'>[
  {
    "type": "paragraph",
    "createdAt": 1734440196000,
    "updatedAt": 1734440215000,
    "children": [{"text": "ç¬¬ä¸€æ®µå†…å®¹"}]
  },
  {
    "type": "paragraph",
    "children": [{"text": "æ— æ—¶é—´æˆ³çš„æ®µè½"}]
  }
]</textarea>
      </div>
      <div class="input-group">
        <label>Event.createdAtï¼ˆå›é€€å€¼ï¼‰ï¼š</label>
        <input type="text" id="eventCreatedAt" value="2025-12-15 13:56:36" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 4px;">
      </div>
      <div class="input-group">
        <label>Event.updatedAtï¼ˆå›é€€å€¼ï¼‰ï¼š</label>
        <input type="text" id="eventUpdatedAt" value="2025-12-15 14:30:00" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 4px;">
      </div>
      <button onclick="testEventLogFlow()">æµ‹è¯•å®Œæ•´æµç¨‹</button>
      <button onclick="clearEventLogOutput()">æ¸…ç©ºç»“æœ</button>
      <div id="eventLogOutput" class="output" style="display: none;"></div>
    </div>

    <!-- æµ‹è¯•åŒºåŸŸ 4: æ—¶åŒºè½¬æ¢æµ‹è¯• -->
    <div class="test-section">
      <h2>4ï¸âƒ£ æ—¶åŒºè½¬æ¢ä¸æ ¼å¼åŒ–æµ‹è¯•</h2>
      <div class="grid-2">
        <div>
          <h3>Unix æ¯«ç§’æ—¶é—´æˆ³ â†’ TimeSpec</h3>
          <input type="number" id="unixInput" value="1734440196000" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 4px; margin-bottom: 8px;">
          <button onclick="testUnixConversion()">è½¬æ¢</button>
          <div id="unixOutput" class="output" style="display: none; margin-top: 10px;"></div>
        </div>
        <div>
          <h3>TimeSpec â†’ Unix æ¯«ç§’æ—¶é—´æˆ³</h3>
          <input type="text" id="timespecInput" value="2025-12-15 13:56:36" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 4px; margin-bottom: 8px;">
          <button onclick="testTimespecConversion()">è½¬æ¢</button>
          <div id="timespecOutput" class="output" style="display: none; margin-top: 10px;"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ==================== å·¥å…·å‡½æ•° ====================

    /**
     * æ ¼å¼åŒ–æ—¥æœŸä¸º TimeSpec æ ¼å¼ï¼ˆYYYY-MM-DD HH:mm:ssï¼‰
     */
    function formatTimeForStorage(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      const hours = String(date.getHours()).padStart(2, '0');
      const minutes = String(date.getMinutes()).padStart(2, '0');
      const seconds = String(date.getSeconds()).padStart(2, '0');
      return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    }

    /**
     * è½¬æ¢æ—¶é—´æˆ³ä¸º TimeSpec æ ¼å¼
     */
    function convertTimestampToTimeSpec(timestamp) {
      if (typeof timestamp === 'number') {
        const converted = formatTimeForStorage(new Date(timestamp));
        console.log('[convertTimestampToTimeSpec]', {
          åŸå§‹å€¼: timestamp,
          ç±»å‹: 'number',
          Dateå¯¹è±¡: new Date(timestamp).toISOString(),
          æœ¬åœ°æ—¶é—´: new Date(timestamp).toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' }),
          è½¬æ¢å: converted
        });
        return converted;
      } else if (typeof timestamp === 'string') {
        console.log('[convertTimestampToTimeSpec] æ—¶é—´æˆ³å·²æ˜¯å­—ç¬¦ä¸²:', timestamp);
        return timestamp;
      }
      return formatTimeForStorage(new Date());
    }

    /**
     * è§£ææ–‡æœ¬ä¸­çš„ Block-Level Timestampï¼ˆæ ¸å¿ƒè§£æé€»è¾‘ï¼‰
     */
    function parseTextWithBlockTimestamps(text) {
      const slateNodes = [];
      const lines = text.split('\n');
      
      console.log('[parseTextWithBlockTimestamps] ğŸ” å¼€å§‹è§£æ:', {
        æ€»è¡Œæ•°: lines.length,
        å‰3è¡Œ: lines.slice(0, 3)
      });
      
      // ğŸ”§ æ—¶é—´æˆ³æ­£åˆ™ï¼ˆä¸¤ç§æ¨¡å¼ï¼‰
      const timestampPattern = /^(\d{4}[-\/]\d{1,2}[-\/]\d{1,2}\s+\d{2}:\d{2}:\d{2})/;
      
      let currentParagraphLines = [];
      let currentTimestamp = null;
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const match = line.match(timestampPattern);
        
        if (match) {
          // é‡åˆ°æ—¶é—´æˆ³è¡Œ
          
          // 1. å…ˆä¿å­˜ä¹‹å‰ç´¯ç§¯çš„æ®µè½å†…å®¹ï¼ˆå¦‚æœæœ‰ï¼‰
          if (currentParagraphLines.length > 0) {
            const paragraphText = currentParagraphLines.join('\n').trim();
            if (paragraphText) {
              const timestamp = currentTimestamp || Date.now();
              slateNodes.push({
                type: 'paragraph',
                createdAt: timestamp,
                updatedAt: timestamp,
                children: [{ text: paragraphText }]
              });
            }
            currentParagraphLines = [];
          }
          
          // 2. è§£ææ–°æ—¶é—´æˆ³
          const timeStr = match[1].replace(/\//g, '-');
          try {
            // ğŸ”§ è§„èŒƒåŒ–æ—¥æœŸæ ¼å¼ï¼šè¡¥é›¶
            const parts = timeStr.split(' ');
            const datePart = parts[0];
            const timePart = parts[1];
            
            const [year, month, day] = datePart.split('-');
            const normalizedDate = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
            const normalizedTimeStr = `${normalizedDate} ${timePart}`;
            
            // âš ï¸ ä½¿ç”¨ YYYY-MM-DD HH:mm:ss æ ¼å¼
            currentTimestamp = new Date(normalizedTimeStr).getTime();
            
            console.log('[parseTextWithBlockTimestamps] âœ… è§£ææ—¶é—´æˆ³:', { 
              åŸå§‹: timeStr, 
              è§„èŒƒåŒ–: normalizedTimeStr,
              Unixæ¯«ç§’: currentTimestamp,
              UTCæ—¶é—´: new Date(currentTimestamp).toISOString(),
              æœ¬åœ°æ—¶é—´: new Date(currentTimestamp).toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' }),
              TimeSpec: formatTimeForStorage(new Date(currentTimestamp))
            });
          } catch (error) {
            console.warn('[parseTextWithBlockTimestamps] è§£ææ—¶é—´æˆ³å¤±è´¥:', timeStr, error);
            currentTimestamp = Date.now();
          }
          
          // 3. æå–æ—¶é—´æˆ³åé¢çš„å†…å®¹ï¼ˆå¦‚æœæœ‰ï¼‰
          const restOfLine = line.substring(match[0].length).trim();
          if (restOfLine) {
            currentParagraphLines.push(restOfLine);
          }
          
        } else {
          // æ™®é€šæ–‡æœ¬è¡Œï¼Œç´¯ç§¯åˆ°å½“å‰æ®µè½
          currentParagraphLines.push(line);
        }
      }
      
      // å¤„ç†æœ€åå‰©ä½™çš„æ®µè½
      if (currentParagraphLines.length > 0) {
        const paragraphText = currentParagraphLines.join('\n').trim();
        if (paragraphText) {
          const timestamp = currentTimestamp || Date.now();
          slateNodes.push({
            type: 'paragraph',
            createdAt: timestamp,
            updatedAt: timestamp,
            children: [{ text: paragraphText }]
          });
        }
      }
      
      console.log('[parseTextWithBlockTimestamps] âœ… è§£æå®Œæˆ:', {
        ç”ŸæˆèŠ‚ç‚¹æ•°: slateNodes.length,
        èŠ‚ç‚¹è¯¦æƒ…: slateNodes.map(n => ({ 
          createdAt: n.createdAt,
          createdAtTimeSpec: formatTimeForStorage(new Date(n.createdAt)),
          æ–‡æœ¬é•¿åº¦: n.children[0]?.text?.length 
        }))
      });
      
      return slateNodes;
    }

    /**
     * æå– EventNodeï¼ˆæ¨¡æ‹Ÿ EventNodeService.extractParagraphsFromEventLogï¼‰
     */
    function extractParagraphsFromEventLog(eventlog, event) {
      const slateJson = typeof eventlog.slateJson === 'string' 
        ? JSON.parse(eventlog.slateJson)
        : eventlog.slateJson;

      if (!Array.isArray(slateJson)) {
        return [];
      }

      const paragraphs = [];

      for (const node of slateJson) {
        const content = node.children
          ?.map(child => child.text || '')
          .join('')
          .trim();

        if (!content) continue;

        // æœ‰ Block-Level Timestamp
        if (node.type === 'paragraph' && node.createdAt) {
          const timestamp = convertTimestampToTimeSpec(node.createdAt);
          const updatedAt = node.updatedAt 
            ? convertTimestampToTimeSpec(node.updatedAt)
            : timestamp;

          console.log('[extractParagraphs] âœ… Block-Level:', {
            createdAt: node.createdAt,
            timestamp,
            content: content.substring(0, 50)
          });

          paragraphs.push({
            content,
            timestamp,
            paragraphCreatedAt: timestamp,
            paragraphUpdatedAt: updatedAt,
            slateNode: node
          });
        } 
        // æ—  Block-Level Timestampï¼Œå›é€€åˆ° Event.createdAt
        else if (node.type === 'paragraph' && !node.createdAt && event) {
          const fallbackTimestamp = event.createdAt || formatTimeForStorage(new Date());
          const fallbackUpdatedAt = event.updatedAt || fallbackTimestamp;

          console.log('[extractParagraphs] âš ï¸ å›é€€åˆ° Event.createdAt:', {
            fallbackTimestamp,
            content: content.substring(0, 50)
          });

          paragraphs.push({
            content,
            timestamp: fallbackTimestamp,
            paragraphCreatedAt: fallbackTimestamp,
            paragraphUpdatedAt: fallbackUpdatedAt,
            slateNode: node
          });
        }
      }

      return paragraphs;
    }

    // ==================== æµ‹è¯•å‡½æ•° ====================

    /**
     * æµ‹è¯•è‡ªå®šä¹‰è¾“å…¥
     */
    function testCustomInput() {
      const input = document.getElementById('customInput').value;
      const output = document.getElementById('customOutput');
      
      output.style.display = 'block';
      output.className = 'output info';
      
      try {
        const result = parseTextWithBlockTimestamps(input);
        
        let html = `ğŸ“Š è§£æç»“æœï¼ˆå…± ${result.length} ä¸ªæ®µè½ï¼‰\n\n`;
        
        result.forEach((node, index) => {
          const createdAtDate = new Date(node.createdAt);
          html += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
          html += `æ®µè½ ${index + 1}:\n`;
          html += `  ğŸ“… createdAt (Unixæ¯«ç§’): ${node.createdAt}\n`;
          html += `  ğŸ• UTCæ—¶é—´: ${createdAtDate.toISOString()}\n`;
          html += `  ğŸ‡¨ğŸ‡³ æœ¬åœ°æ—¶é—´: ${createdAtDate.toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' })}\n`;
          html += `  âœ… TimeSpecæ ¼å¼: ${formatTimeForStorage(createdAtDate)}\n`;
          html += `  ğŸ“ å†…å®¹: ${node.children[0].text}\n\n`;
        });
        
        html += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
        html += `ğŸ” åŸå§‹ JSON:\n${JSON.stringify(result, null, 2)}`;
        
        output.textContent = html;
        output.className = 'output success';
      } catch (error) {
        output.textContent = `âŒ è§£æå¤±è´¥:\n${error.message}\n\n${error.stack}`;
        output.className = 'output error';
      }
    }

    /**
     * è¿è¡Œæ‰€æœ‰é¢„è®¾æµ‹è¯•
     */
    function runAllTests() {
      const output = document.getElementById('testOutput');
      output.style.display = 'block';
      output.className = 'output info';
      
      const testCases = [
        {
          name: 'æµ‹è¯• 1: æ ‡å‡†æ ¼å¼ï¼ˆæ—¶é—´æˆ³ç‹¬ç«‹æˆè¡Œï¼‰',
          input: '2025-12-15 13:56:36\nç¬¬ä¸€æ®µå†…å®¹\n\n2025-12-15 14:30:00\nç¬¬äºŒæ®µå†…å®¹'
        },
        {
          name: 'æµ‹è¯• 2: æ—¶é—´æˆ³+å†…å®¹åœ¨åŒä¸€è¡Œ',
          input: '2025-12-15 13:56:36 è¿™è¡Œæœ‰æ—¶é—´æˆ³å’Œå†…å®¹\nåç»­å†…å®¹'
        },
        {
          name: 'æµ‹è¯• 3: æ–œæ åˆ†éš”ç¬¦',
          input: '2025/12/15 13:56:36\nå†…å®¹'
        },
        {
          name: 'æµ‹è¯• 4: å•ä½æ•°æœˆä»½/æ—¥æœŸ',
          input: '2025-12-7 13:56:36\nå†…å®¹'
        },
        {
          name: 'æµ‹è¯• 5: æ··åˆæ ¼å¼',
          input: '2025-12-15 13:56:36\nç¬¬ä¸€æ®µ\n\n2025/12/7 14:30:00 ç¬¬äºŒæ®µåŒè¡Œ\nç¬¬äºŒæ®µç»­'
        },
        {
          name: 'æµ‹è¯• 6: Unix æ¯«ç§’æ—¶é—´æˆ³ï¼ˆ1734440196000 = 2025-12-17 22:16:36 æœ¬åœ°æ—¶é—´ï¼‰',
          input: 'ç›´æ¥æµ‹è¯• Unix è½¬æ¢',
          unixTest: 1734440196000
        }
      ];
      
      let html = '';
      testCases.forEach((testCase, index) => {
        html += `\n${'='.repeat(60)}\n`;
        html += `${testCase.name}\n`;
        html += `${'='.repeat(60)}\n\n`;
        
        if (testCase.unixTest) {
          const date = new Date(testCase.unixTest);
          html += `Unix æ¯«ç§’: ${testCase.unixTest}\n`;
          html += `UTC: ${date.toISOString()}\n`;
          html += `æœ¬åœ°æ—¶é—´: ${date.toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' })}\n`;
          html += `TimeSpec: ${formatTimeForStorage(date)}\n`;
        } else {
          html += `è¾“å…¥:\n${testCase.input}\n\n`;
          
          try {
            const result = parseTextWithBlockTimestamps(testCase.input);
            html += `âœ… æˆåŠŸè§£æ ${result.length} ä¸ªæ®µè½:\n\n`;
            
            result.forEach((node, i) => {
              const createdAtDate = new Date(node.createdAt);
              html += `  æ®µè½ ${i + 1}:\n`;
              html += `    createdAt: ${node.createdAt}\n`;
              html += `    TimeSpec: ${formatTimeForStorage(createdAtDate)}\n`;
              html += `    å†…å®¹: ${node.children[0].text}\n\n`;
            });
          } catch (error) {
            html += `âŒ å¤±è´¥: ${error.message}\n`;
          }
        }
      });
      
      output.textContent = html;
    }

    /**
     * æµ‹è¯• EventLog å®Œæ•´æµç¨‹
     */
    function testEventLogFlow() {
      const slateJsonInput = document.getElementById('eventLogInput').value;
      const eventCreatedAt = document.getElementById('eventCreatedAt').value;
      const eventUpdatedAt = document.getElementById('eventUpdatedAt').value;
      const output = document.getElementById('eventLogOutput');
      
      output.style.display = 'block';
      
      try {
        const slateJson = JSON.parse(slateJsonInput);
        const eventlog = { slateJson };
        const event = { 
          createdAt: eventCreatedAt, 
          updatedAt: eventUpdatedAt 
        };
        
        const paragraphs = extractParagraphsFromEventLog(eventlog, event);
        
        let html = `ğŸ“Š EventLog â†’ EventNode å®Œæ•´æµç¨‹æµ‹è¯•\n\n`;
        html += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
        html += `è¾“å…¥ Event:\n`;
        html += `  createdAt: ${eventCreatedAt}\n`;
        html += `  updatedAt: ${eventUpdatedAt}\n\n`;
        
        html += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
        html += `è§£æç»“æœï¼ˆå…± ${paragraphs.length} ä¸ª EventNodeï¼‰:\n\n`;
        
        paragraphs.forEach((para, index) => {
          html += `EventNode ${index + 1}:\n`;
          html += `  content: ${para.content}\n`;
          html += `  timestamp: ${para.timestamp}\n`;
          html += `  paragraphCreatedAt: ${para.paragraphCreatedAt}\n`;
          html += `  paragraphUpdatedAt: ${para.paragraphUpdatedAt}\n`;
          html += `  æ¥æº: ${para.slateNode.createdAt ? 'Block-Level Timestamp' : 'Event.createdAtï¼ˆå›é€€ï¼‰'}\n\n`;
        });
        
        html += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
        html += `ğŸ” è¯¦ç»† JSON:\n${JSON.stringify(paragraphs, null, 2)}`;
        
        output.textContent = html;
        output.className = 'output success';
      } catch (error) {
        output.textContent = `âŒ æµ‹è¯•å¤±è´¥:\n${error.message}\n\n${error.stack}`;
        output.className = 'output error';
      }
    }

    /**
     * æµ‹è¯• Unix è½¬æ¢
     */
    function testUnixConversion() {
      const unix = parseInt(document.getElementById('unixInput').value);
      const output = document.getElementById('unixOutput');
      
      output.style.display = 'block';
      
      const date = new Date(unix);
      const timespec = formatTimeForStorage(date);
      
      let html = `Unix æ¯«ç§’: ${unix}\n`;
      html += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
      html += `Date å¯¹è±¡: ${date}\n`;
      html += `UTC æ—¶é—´: ${date.toISOString()}\n`;
      html += `æœ¬åœ°æ—¶é—´: ${date.toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' })}\n`;
      html += `TimeSpec: ${timespec}\n`;
      html += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
      html += `æ—¶åŒºåç§»: UTC${date.getTimezoneOffset() / -60 >= 0 ? '+' : ''}${date.getTimezoneOffset() / -60}`;
      
      output.textContent = html;
      output.className = 'output success';
    }

    /**
     * æµ‹è¯• TimeSpec è½¬æ¢
     */
    function testTimespecConversion() {
      const timespec = document.getElementById('timespecInput').value;
      const output = document.getElementById('timespecOutput');
      
      output.style.display = 'block';
      
      try {
        const date = new Date(timespec);
        const unix = date.getTime();
        
        let html = `TimeSpec: ${timespec}\n`;
        html += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
        html += `Date å¯¹è±¡: ${date}\n`;
        html += `Unix æ¯«ç§’: ${unix}\n`;
        html += `UTC æ—¶é—´: ${date.toISOString()}\n`;
        html += `æœ¬åœ°æ—¶é—´: ${date.toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' })}\n`;
        html += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
        html += `åå‘éªŒè¯: ${formatTimeForStorage(date)}`;
        
        output.textContent = html;
        output.className = 'output success';
      } catch (error) {
        output.textContent = `âŒ è§£æå¤±è´¥:\n${error.message}`;
        output.className = 'output error';
      }
    }

    // ==================== æ¸…ç©ºå‡½æ•° ====================
    
    function clearCustomOutput() {
      document.getElementById('customOutput').style.display = 'none';
    }
    
    function clearTestOutput() {
      document.getElementById('testOutput').style.display = 'none';
    }
    
    function clearEventLogOutput() {
      document.getElementById('eventLogOutput').style.display = 'none';
    }

    // ==================== é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨è¿è¡Œä¸€æ¬¡æµ‹è¯• ====================
    
    window.addEventListener('load', () => {
      console.log('ğŸš€ Block-Level Timestamp è°ƒè¯•å·¥å…·å·²åŠ è½½');
      console.log('å½“å‰æ—¶åŒº:', Intl.DateTimeFormat().resolvedOptions().timeZone);
      console.log('æ—¶åŒºåç§»:', new Date().getTimezoneOffset() / -60, 'å°æ—¶');
    });
  </script>
</body>
</html>
